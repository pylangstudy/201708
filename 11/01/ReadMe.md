# [6.2.1. 正規表現のシンタックス](https://docs.python.jp/3/library/re.html#regular-expression-syntax)

< [6.2. re — 正規表現操作](https://docs.python.jp/3/library/re.html#module-re) < [6. テキスト処理サービス](https://docs.python.jp/3/library/text.html#text-processing-services) < [Python 標準ライブラリ](https://docs.python.jp/3/library/index.html#the-python-standard-library) < [ドキュメント](https://docs.python.jp/3/index.html)

正規表現の説明。知ってるの前提だと辛いので助かる。

## 概要

> 正規表現 (すなわち RE) は、表現にマッチ (match) する文字列の集合を表しています。このモジュールの関数を使えば、ある文字列が指定の正規表現にマッチするか (または指定の正規表現がある文字列にマッチするか、つまりは同じことですが) を検査できます。

### 連結

> 正規表現を連結すると新しい正規表現を作れます。 A と B がともに正規表現であれば AB も正規表現です。一般的に、文字列 p が A　とマッチし、別の文字列 q が B とマッチすれば、文字列 pq は AB にマッチします。ただし、この状況が成り立つのは、 A と B との間に境界条件がある場合や、番号付けされたグループ参照のような、優先度の低い演算を A や B が含まない場合だけです。かくして、ここで述べるような、より簡単でプリミティブな正規表現から、複雑な正規表現を容易に構築できます。正規表現に関する理論と実装の詳細については上記の Friedl 本か、コンパイラの構築に関する教科書を調べて下さい。

## 基礎

> 以下で正規表現の形式に関する簡単な説明をしておきます。より詳細な情報やよりやさしい説明に関しては、 正規表現 HOWTO を参照してください。

### 文字種

> 正規表現には、特殊文字と通常文字の両方を含められます。

#### 通常文字

>  'A' 、 'a' 、あるいは '0' のようなほとんどの通常文字は最も簡単な正規表現になります。こうした文字は、単純にその文字自体にマッチします。通常の文字は連結できるので、 last は文字列 'last' とマッチします。 (この節の以降の説明では、正規表現を引用符を使わずに この表示スタイル: special style で書き、マッチ対象の文字列は、 '引用符で括って' 書きます。)

#### 特殊文字

> '|' や '(' といったいくつかの文字は特殊文字です。特殊文字は通常の文字の種別を表したり、あるいは特殊文字の周辺にある通常の文字に対する解釈方法に影響します。正規表現パターン文字列には、null byte を含めることができませんが、 '\x00' のような \number 記法を利用して指定することができます。

> 繰り返しの修飾子 (*, +, ?, {m,n} など) は直接入れ子にはできません。 これによって、非貪欲な修飾子の接尾辞 ? や他の実装での他の修飾子についての曖昧さを回避しています。 繰り返しのある正規表現の外側にさらに繰り返しを適用するには丸括弧が使えます。 例えば、正規表現 (?:a{6})* は6つの 'a' の0回以上の繰り返しに適合します。

## 特殊文字一覧

特殊文字を以下に示します:


特殊文字|読み|説明
--------|----|----
'.'|ドット|デフォルトのモードでは改行以外の任意の文字にマッチします。 DOTALL フラグが指定されていれば改行も含むすべての文字にマッチします。
'^'|キャレット|文字列の先頭とマッチします。 MULTILINE モードでは各改行の直後にマッチします。
'$'|ダラー|文字列の末尾、あるいは文字列の末尾の改行の直前にマッチします。例えば、 foo は ‘foo’ と ‘foobar’ の両方にマッチします。一方、正規表現 foo$ は ‘foo’ だけとマッチします。興味深いことに、 'foo1\nfoo2\n' を foo.$ で検索した場合、通常のモードでは ‘foo2’ だけにマッチし、 MULTILINE モードでは ‘foo1’ にもマッチします。 $ だけで 'foo\n' を検索した場合、2箇所 (内容は空) でマッチします: 1つは、改行の直前で、もう1つは、文字列の最後です。
'*'|アスタリスク|直前にある RE に作用して、 RE を 0 回以上できるだけ多く繰り返したものにマッチさせるようにします。例えば ab* は ‘a’、’ab’、あるいは ‘a’ に任意個数の’b’ を続けたものにマッチします。
'+'|プラス|直前にある RE に作用して、 RE を、1 回以上繰り返したものにマッチさせるようにします。例えば ab+ は ‘a’ に一つ以上の ‘b’ が続いたものにマッチし、 ‘a’ 単体にはマッチしません。
'?'|クエスチョン|直前にある RE に作用して、 RE を 0 回か 1 回繰り返したものにマッチさせるようにします。例えば ab? は ‘a’ あるいは ‘ab’ にマッチします。
*?, +?, ??||'*' 、 '+' 、 '?' といった修飾子は、すべて 貪欲 (greedy) マッチ、すなわちできるだけ多くのテキストにマッチするようになっています。時にはこの動作が望ましくない場合もあります。例えば正規表現 <.*> を <a> b <c> にマッチさせると、 <a> だけにマッチするのではなく全文字列にマッチしてしまいます。 ? を修飾子の後に追加すると、 非貪欲 (non-greedy) あるいは 最小一致 (minimal) のマッチになり、できるだけ 少ない 文字数のマッチになります。例えば正規表現 <.*?> を使うと <a> だけにマッチします。
{m}|中括弧|前にある RE の m 回の正確なコピーとマッチすべきであることを指定します；マッチ回数が少なければ、RE 全体ではマッチしません。例えば、 a{6} は、正確に 6個の 'a' 文字とマッチしますが、 5個ではマッチしません。
{m,n}|中括弧|結果の RE は、前にある RE を、 m 回から n 回まで繰り返したもので、できるだけ多く繰り返したものとマッチするように、マッチします。例えば、 a{3,5} は、3個から 5個の 'a' 文字とマッチします。 m を省略するとマッチ回数の下限として0を指定した事になり、 n を省略することは、上限が無限であることを指定します； a{4,}b は aaaab や、千個の 'a' 文字に b が続いたものとマッチしますが、 aaab とはマッチしません。コンマは省略できません、そうでないと修飾子が上で述べた形式と混同されてしまうからです。
{m,n}?|結果の RE は、前にある RE の m 回から n 回まで繰り返したもので、できるだけ 少なく 繰り返したものとマッチするように、マッチします。これは、前の修飾子の控え目バージョンです。例えば、 6文字文字列 'aaaaaa' では、 a{3,5} は、5個の 'a' 文字とマッチしますが、 a{3,5}? は3個の文字とマッチするだけです。
'\'|バックスラッシュ|特殊文字をエスケープする( '*' や '?' 等のような文字とのマッチをできるようにする) か、あるいは、特殊シーケンスの合図です; 特殊シーケンスは後で議論します。もしパターンを表現するのに raw string を使用していないのであれば、 Python も、バックスラッシュを文字列リテラルでのエスケープシーケンスとして使っていることを覚えていて下さい。エスケープシーケンスを Python の構文解析器が認識して処理しない場合、そのバックスラッシュとそれに続く文字は、結果の文字列にそのまま含まれます。しかし、Python が結果のシーケンスを認識する場合は、バックスラッシュを 2回繰り返さなければいけません。これは複雑で理解しにくいので、最も簡単な表現以外は、すべて raw string を使うことを強く推奨します。
[]|角括弧|文字の集合を指定するのに使用します。集合には以下のものが指定できます:1:「[amk] は 'a', 'm', 'k' とマッチします」 2:「[a-z] はすべての小文字の ASCII 文字とマッチします」 3:「[0-5][0-9] は 00 から 59 までの、すべての 2 桁の数字とマッチします。」 4:「 [0-9A-Fa-f] は任意の 16 進数の数字とマッチします。」 5:「[(+*)] はリテラル文字 '(' '+' 、 '*' 、あるいは ')' のいずれかとマッチします」 6:「\w や \S のような文字クラスはASCII か LOCALE のどちらか有効にされているモードに依存します」 7:「集合の最初の文字が '^' の時、集合に ない 文字すべてとマッチします（^ は集合の最初の文字でない限り特別の意味を持ちません。）」 8:「[^^] は '^' を除くあらゆる文字にマッチします」 9:「集合内でリテラル ']' をマッチさせるには、その前にバックスラッシュをつけるか、集合の先頭に置きます。 [()[\]{}] と []()[{}] はどちらも ']' にマッチします。」
'|'|縦線|A と B を任意の RE としたとき、A|B は A か B のどちらかとマッチする正規表現を作成します。任意個数の RE を、このように '|' で分離することができます。これはグループ (以下参照) 内部でも同様に使えます。検査対象文字列をスキャンする中で、 '|' で分離された RE は左から右への順に検査されます。一つでも完全にマッチしたパターンがあれば、そのパターン枝が受理されます。つまり、A がマッチした場合、たとえ B によるマッチが全体としてより長いマッチになったとしても、 B をスキャンしません。言いかえると、 '|' 演算子は決して貪欲 (greedy) ではありません。文字通りの '|' とマッチするには、 \| を使うか、あるいはそれを [|] のように文字クラス内に入れます。
(...)|丸括弧|丸括弧の中にどのような正規表現があってもマッチし、またグループの先頭と末尾を表します；グループの中身は、マッチが実行された後に検索され、後述する \number 特殊シーケンス付きの文字列内で、後でマッチされます。文字通りの '(' や ')' とマッチするには、 \( あるいは \) を使うか、それらを文字クラス内に入れます： [(] [)] 。
(?...)||これは拡張記法です ('(' に続く '?' は他には意味がありません) 。 '?' の後の最初の文字が、この構造の意味とこれ以上のシンタックスがどういうものであるかを決定します。拡張記法は普通新しいグループを作成しません； (?P<name>...) がこの規則の唯一の例外です。以下に現在サポートされている拡張記法を示します。
(?aiLmsux)||(One or more letters from the set 'a', 'i', 'L', 'm', 's', 'u', 'x'.) The group matches the empty string; the letters set the corresponding flags: re.A (ASCII-only matching), re.I (ignore case), re.L (locale dependent), re.M (multi-line), re.S (dot matches all), and re.X (verbose), for the entire regular expression. (The flags are described in モジュールコンテンツ.) This is useful if you wish to include the flags as part of the regular expression, instead of passing a flag argument to the re.compile() function. Flags should be used first in the expression string.
(?:...)||正規表現の丸括弧の取り込まないバージョンです。どのような正規表現が丸括弧内にあってもマッチしますが、グループによってマッチされたサブ文字列は、マッチを実行したあと検索されることも、あるいは後でパターンで参照されることも できません 。
(?imsx-imsx:...)||(Zero or more letters from the set 'i', 'm', 's', 'x', optionally followed by '-' followed by one or more letters from the same set.) The letters set or removes the corresponding flags: re.I (ignore case), re.M (multi-line), re.S (dot matches all), and re.X (verbose), for the part of the expression. (The flags are described in モジュールコンテンツ.) バージョン 3.6 で追加.
(?P<name>...)||正規表現の丸括弧に似ていますが、グループによってマッチした部分文字列はシンボリックグループ名 name によってアクセス可能になります。グループ名は有効な Python 識別子でなければならず、グループ名は 1 個の正規表現内で一意でなければなりません。シンボリックグループは番号付けもされており、番号によるアクセスも可能です。
(?P=name)||名前付きグループへの後方参照です; 既出のグループ名 name にマッチする文字列は何にでもマッチします。
(?#...)||コメントです；括弧の内容は単純に無視されます。
(?=...)||先読みアサーション。Isaac (?=Asimov) は、 'Isaac ' に 'Asimov' が続く場合だけ、 'Isaac ' とマッチします。
(?!...)||否定先読みアサーション。Isaac (?!Asimov) は、 'Isaac ' に 'Asimov' が続か ない 場合のみマッチします。
(?<=...)||後読みアサーション。(?<=abc)def は abcdef にマッチを見つけます。
(?<!...)||否定後読みアサーション。文字列内の現在位置の前に ... とのマッチがない場合に、マッチします。
(?(id/name)yes-pattern|no-pattern)|与えられたグループ id あるいは name が存在する場合、yes-pattern とのマッチを、存在しない場合 no-pattern とのマッチを試みます。
\number||同じ番号のグループの中身とマッチします。グループは1から始まる番号をつけられます。例えば、 (.+) \1 は、 'the the' あるいは '55 55' とマッチしますが、 'thethe' とはマッチしません(グループの後のスペースに注意して下さい)。
\A||文字列の先頭だけにマッチします。
\b||空文字列とマッチしますが、単語の先頭か末尾の時だけです。単語とは Unicode 英数字 (日本語など英字以外も含む非記号) またはアンダースコアからなるシーケンスで、単語の終わりは空白文字、あるいはアンダースコアを除く記号で表します。\b は \w および \W の間 (およびその逆) あるいは \w と文字列の開始/終了との間の境界として定義されています。例えば、r'\bfoo\b' は 'foo' , 'foo.' , '(foo)', 'bar foo baz' にマッチしますが、'foobar', 'foo3' にはマッチしません。
\D||任意の非 Unicode 10 進数文字にマッチします。これは \d の反対です。ASCII フラグを使用すると [^0-9] と等価になります。ただし、このフラグは正規表現全体に作用しますので、明示的に [^0-9] と指定する方が良い場合があるかもしれません。
\s||ユニコード (str) パターンに対して:「任意の空白文字とマッチします。これには [ \t\n\r\f\v] およびノーブレークスペースなど、多くの言語におけるタイポグラフィ規則で定義された文字が含まれます。ASCII フラグを使用すると、[ \t\n\r\f\v] のみにマッチします。ただし、このフラグは正規表現全体に作用しますので、明示的に [ \t\n\r\f\v] と指定する方が良い場合があるかもしれません。」8bit (bytes) パターンに対して:「ASCII 文字セットにおける空白文字とマッチします。これは [ \t\n\r\f\v] と等価です。」
\S||任意の非空白文字にマッチします。これは \s の反対です。ASCII フラグを使用すると [^ \t\n\r\f\v] と等価になります。ただし、このフラグは正規表現全体に作用しますので、明示的に [^ \t\n\r\f\v] と指定する方が良い場合があるかもしれません。
\w||ユニコード (str) パターンに対して:「任意の Unicode 単語文字にマッチします。これにはあらゆる言語で単語の一部になりうる文字、数字、およびアンダースコアが含まれます。ASCII フラグを使用すると [a-zA-Z0-9_] のみにマッチします。ただし、このフラグは正規表現全体に作用しますので、明示的に [a-zA-Z0-9_] と指定する方が良い場合があるかもしれません。」8bit (bytes) パターンに対して:「ASCII 文字セットでの英数字とアンダースコアにマッチします。これは [a-zA-Z0-9_] と等価です。」
\W||任意の非 Unicode 単語文字にマッチします。これは \w の反対です。ASCII フラグを使用した場合、[^a-zA-Z0-9_] と等価になります。ただし、このフラグは正規表現全体に作用しますので、明示的に [^a-zA-Z0-9_] と指定する方が良い場合があるかもしれません。
\Z||文字列の末尾とのみマッチします。`\a,\b,\f,\n,\r,\t,\u,\U,\v,\x,\\`。(\b は単語の境界を表し、文字クラス内でのみ後退 (backspace) 文字を指すことに注意してください)。'\u' および '\U' エスケープシーケンスは Unicode パターン内でのみ認識されます。バイト列では特殊文字として扱われません。8 進数エスケープは限られた形式で表します。最初の桁が 0 か、あるいは 3 桁の 8 進数ならば、8 進数エスケープとみなされます。それ以外の場合はグループ参照になります。文字列リテラルに関しては、8 進数エスケープはほとんどの場合 3 桁長になります。

## 参考

> Mastering Regular Expressions 詳説正規表現

>    Jeffrey Friedl 著、O’Reilly 刊の正規表現に関する本です。この本の第2版ではPyhonについては触れていませんが、良い正規表現パターンの書き方を非常にくわしく説明しています。

宣伝乙。

## 試してみる

### 参考

Web上で試せるツールを探した。

* https://nelog.jp/regular-expression-online-tools
* http://qiita.com/AQRiL_1132/items/c185c7ad84c129e5a2df

### Webツール

URL|Python正規表現|URLシェア|入力の楽さ|見やすさ|応答速度|Pythonソースコード生成
---|--------------|---------|----------|--------|--------|----------------------
https://regex101.com/|○|○|○|○|✗|○
https://www.debuggex.com/|○|○|△|○|○|?
http://www.rexv.org/|○|✗|△|○|○|?
http://www.regexplanet.com/|○|○|✗|✗|?

Pythonの正規表現に対応したツール。

https://translate.googleusercontent.com/translate_c?act=url&depth=1&hl=ja&ie=UTF8&prev=_t&rurl=translate.google.co.jp&sl=en&sp=nmt4&tl=ja&u=https://github.com/firasdib/Regex101/wiki/FAQ&usg=ALkJrhg6mpYcn6-tWF9X-lZiNLa2aAFZYQ

